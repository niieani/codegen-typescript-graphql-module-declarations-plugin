// based off '@graphql-codegen/typescript-graphql-files-modules'
import { basename, relative } from 'path'
// eslint-disable-next-line import/no-extraneous-dependencies
import {
  concatAST,
  FragmentDefinitionNode,
  GraphQLSchema,
  Kind,
  OperationDefinitionNode,
  // eslint-disable-next-line node/no-unpublished-import
} from 'graphql'
import { pascalCase } from 'pascal-case'
import type {
  PluginFunction,
  PluginValidateFn,
  Types,
} from '@graphql-codegen/plugin-helpers'
import type {
  LoadedFragment,
  RawClientSideBasePluginConfig,
} from '@graphql-codegen/visitor-plugin-common'
import { TypeScriptDocumentNodesVisitor } from './visitor'

/**
 * @description This plugin is based on the TypeScript GraphQL Files Modules,
 * but generates typed document nodes, using the types generated
 * by TypedDocumentNode plugin.
 *
 * You need to run graphql-code-generator with the TypedDocumentNode plugin first
 * and set `typedDocumentNodeModule` option to the module path of the generated file.
 *
 * This plugin generates TypeScript typings for `.graphql` files containing GraphQL documents, which later on can be consumed using [`graphql-tag/loader`](https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader) or use `string` types if you will use the operations as raw strings, and get type-check and type-safety for your imports. This means that any time you import objects from `.graphql` files, your IDE will provide auto-complete.
 *
 * This plugin also handles `.graphql` files containing multiple GraphQL documents, and name the imports according to the operation name.
 *
 * > âš  Fragments are not generated with named imports, only as default imports, due to `graphql-tag/loader` behavior.
 */
export interface TypeScriptGraphQLModuleDeclarationsPluginConfig
  extends RawClientSideBasePluginConfig {
  /**
   * @default ""
   * @description Allows specifying a module definition path prefix to provide distinction
   * between generated types.
   *
   * @exampleMarkdown
   * ```yml
   * generates: src/api/user-service/queries.d.ts
   *  documents: src/api/user-service/queries.graphql
   *  plugins:
   *    - typescript-graphql-files-modules
   *  config:
   *    # resulting module definition path glob: "*\/api/user-service/queries.graphql"
   *    modulePathPrefix: "/api/user-service/"
   * ```
   */
  modulePathPrefix?: string
  /**
   * @description By default, only the filename is being used to generate TS module declarations. Setting this will generate it with a full path based on the path provided.
   */
  relativeTo: string
  /**
   * @description Where should the file which was generated by the typed-document-node plugin be imported from.
   */
  typedDocumentNodeModule: string
  /**
   * @default *\/
   * @description By default, a wildcard is being added as prefix, you can change that to a custom prefix
   */
  prefix?: string
}

export const plugin: PluginFunction = (
  schema: GraphQLSchema,
  documents: Types.DocumentFile[],
  config: TypeScriptGraphQLModuleDeclarationsPluginConfig,
): string => {
  const {
    modulePathPrefix = '',
    relativeTo,
    prefix = '',
    typedDocumentNodeModule,
  } = config

  const allAst = concatAST(documents.map((v) => v.document!))

  const allFragments: LoadedFragment[] = [
    ...(
      allAst.definitions.filter(
        (d) => d.kind === Kind.FRAGMENT_DEFINITION,
      ) as FragmentDefinitionNode[]
    ).map((fragmentDef) => ({
      node: fragmentDef,
      name: fragmentDef.name.value,
      onType: fragmentDef.typeCondition.name.value,
      isExternal: false,
    })),
  ]

  const visitor = new TypeScriptDocumentNodesVisitor(
    schema,
    allFragments,
    config,
    documents,
  )

  const useRelative = Boolean(relativeTo)

  const mappedDocuments = documents.reduce<
    Record<string, (OperationDefinitionNode | FragmentDefinitionNode)[]>
  >((prev, documentRecord) => {
    const fileName = useRelative
      ? relative(relativeTo, documentRecord.location!)
      : basename(documentRecord.location!)

    if (!prev[fileName]) {
      // eslint-disable-next-line no-param-reassign
      prev[fileName] = []
    }

    if (!documentRecord.document) return prev

    prev[fileName]?.push(
      ...documentRecord.document.definitions.filter(
        (
          document,
        ): document is OperationDefinitionNode | FragmentDefinitionNode =>
          document.kind === 'OperationDefinition' ||
          document.kind === 'FragmentDefinition',
      ),
    )

    return prev
  }, {})

  return Object.entries(mappedDocuments)
    .filter(([fileName, operations]) => operations.length > 0)
    .map(([fileName, operations]) => {
      const namedOperations = operations.filter((d) => d.name?.value)
      const nodesWithNames = namedOperations.map((node) => {
        // based on https://github.com/dotansimha/graphql-code-generator/blob/a790904a1ae42e63ef8552c9b0145f5f3292d474/packages/plugins/other/visitor-plugin-common/src/client-side-base-visitor.ts#L552-L566
        const documentVariableName = visitor.convertName(node, {
          suffix: visitor.config.documentVariableSuffix,
          prefix: visitor.config.documentVariablePrefix,
          useTypesPrefix: false,
        })

        if (node.kind === 'FragmentDefinition') {
          return {
            documentVariableName,
            resultType: visitor.getFragmentName(node),
            variablesType: 'unknown',
            node,
          }
        }
        const operationType: string = pascalCase(node.operation)
        const operationTypeSuffix: string = visitor.getOperationSuffix(
          node,
          operationType,
        )
        const resultType: string = visitor.convertName(node, {
          suffix: `${operationTypeSuffix}${visitor.config.operationResultSuffix}`,
        })
        const variablesType: string = visitor.convertName(node, {
          suffix: `${operationTypeSuffix}Variables`,
        })
        return {
          documentVariableName,
          resultType,
          variablesType,
          node,
        }
      })
      if (nodesWithNames.length === 0) return ``

      const defaultExport =
        nodesWithNames.find(
          ({ node }) => node.kind === 'OperationDefinition',
        ) ?? nodesWithNames[0]

      if (!defaultExport) return ''

      return `
declare module '${prefix}${modulePathPrefix}${fileName}' {
  import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
  const defaultDocument: DocumentNode<import('${typedDocumentNodeModule}').${
        defaultExport.resultType
      }, import('${typedDocumentNodeModule}').${defaultExport.variablesType}>;
  ${nodesWithNames
    .map(
      ({ node, resultType }) =>
        `export const ${node.name?.value}: import('${typedDocumentNodeModule}').${resultType};`,
    )
    .join('\n')}
  export default defaultDocument;
}
    `
    })
    .join('\n')
}

export const validate: PluginValidateFn<unknown> = (
  schema: GraphQLSchema,
  documents: Types.DocumentFile[],
  config: unknown,
  outputFile: string,
) => {
  if (!outputFile.endsWith('.d.ts')) {
    throw new Error(
      `Plugin "codegen-typescript-graphql-module-declarations" requires extension to be ".d.ts"!`,
    )
  }
}
